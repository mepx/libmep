// Multi Expression Programming library
// Author: Mihai Oltean, mihai.oltean@gmail.com
// https://mepx.org
// https://github.com/mepx
// License: MIT
//-----------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
//---------------------------------------------------------------------------------
#include "mep_chromosome.h"
#include "mep_functions.h"
#include "utils/func_utils.h"
//---------------------------------------------------------------------------------
char* t_mep_chromosome::to_Latex_code(const char* libmep_version)
{
	char* old_locale = setlocale(LC_NUMERIC, NULL);
	char* saved_locale = strdup (old_locale);
	setlocale(LC_NUMERIC, "C");

	char* prog = new char[1000];
	char *tmp_s = new char[100];
	prog[0] = 0;
	snprintf(tmp_s, 100, "%%Generated by libmep version %s\n\n", libmep_version);
	strcat(prog, "\\documentclass{article}\n");
	strcat(prog, "\\begin{document}\n");
	strcat(prog, "\n");


	size_t string_capacity = 1000;
	//size_t tmp_s_capacity = 100;

	switch (problem_type) {
	case MEP_PROBLEM_REGRESSION:
	case MEP_PROBLEM_TIME_SERIE:
		if (num_program_outputs > 1){
			for (unsigned int i = 0; i < num_program_outputs; i++){
				increase_string_capacity2(prog, string_capacity, 100);
				strcat(prog, "\\[\n");
				snprintf(tmp_s, 100, "  mepx_{%u} = ", i);
				strcat(prog, tmp_s);
					
				code_to_Latex(index_best_genes[i], prog, string_capacity);
				increase_string_capacity2(prog, string_capacity, 100);
				strcat(prog, "\n");
				strcat(prog, "\\]\n");
			}
		}
		else{ // one output
			strcat(prog, "\\[\n");
			strcat(prog, "  mepx = ");
				
			code_to_Latex(index_best_genes[0], prog, string_capacity);
			increase_string_capacity2(prog, string_capacity, 100);
			strcat(prog, "\n");
			strcat(prog, "\\]\n");
		}
		
		break;

	case MEP_PROBLEM_BINARY_CLASSIFICATION:
			strcat(prog, "\\[\n");
			strcat(prog, "  mepx = \\left\\{\n");
			strcat(prog, "\\begin{array}{ll}\n");
			//code_to_Latex(index_best_genes[0], tmp_s, tmp_s_capacity);
			
			snprintf(tmp_s, 100, "%d & ", class_labels[0]);
			strcat(prog, tmp_s);
			code_to_Latex(index_best_genes[0], prog, string_capacity);
			snprintf(tmp_s, 100, " <= %lf\\\\\n", best_class_threshold);
			strcat(prog, tmp_s);
			
			snprintf(tmp_s, 100, "%d & otherwise\\\\\n", class_labels[1]);
			strcat(prog, tmp_s);

			strcat(prog, "\\end{array}\n");
			strcat(prog, "\\right.");
			increase_string_capacity2(prog, string_capacity, 100);
			strcat(prog, "\n");
			strcat(prog, "\n");
			strcat(prog, "\\]\n");

		
		break;
	case MEP_PROBLEM_MULTICLASS_CLASSIFICATION:
		switch (error_measure) {
		case MEP_MULTICLASS_CLASSIFICATION_WINNER_TAKES_ALL_ERROR:
		case MEP_MULTICLASS_CLASSIFICATION_SMOOTH_ERROR:
		case MEP_MULTICLASS_CLASSIFICATION_WINNER_TAKES_ALL_DYNAMIC_ERROR:
		case MEP_MULTICLASS_CLASSIFICATION_CLOSEST_CENTER_ERROR:
			strcat(prog, "% Currently there is no code generated for this case! Use the standard C++ code for this strategy.");
			break;

		}// end switch error_measure
		break;
	} // end switch (problem_type)
	
	strcat(prog, "\n");
	strcat(prog, "\\end{document}\n");

	setlocale(LC_NUMERIC, saved_locale);
	free (saved_locale);

	delete[] tmp_s;
	
	return prog;
}
//---------------------------------------------------------------------------
void t_mep_chromosome::code_to_Latex(unsigned int mep_index,
									   char*& s_prg,
									   size_t &capacity)
{
	switch (prg[mep_index].op) {
	case O_ADDITION:
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		increase_string_capacity2(s_prg, capacity, 1);
		strcat(s_prg, "+");
		code_to_Latex(prg[mep_index].addr2, s_prg, capacity);
		break;
	case O_SUBTRACTION:
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		increase_string_capacity2(s_prg, capacity, 1);
		strcat(s_prg, "-");
		if (prg[prg[mep_index].addr2].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}
		code_to_Latex(prg[mep_index].addr2, s_prg, capacity);
		if (prg[prg[mep_index].addr2].op < 0) {
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}
		break;
	case O_MULTIPLICATION:
		if (prg[prg[mep_index].addr1].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		if (prg[prg[mep_index].addr1].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "*");
		if (prg[prg[mep_index].addr2].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}
		code_to_Latex(prg[mep_index].addr2, s_prg, capacity);
		if (prg[prg[mep_index].addr2].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}
		break;
	case O_DIVISION:
		increase_string_capacity2(s_prg, capacity, 8);
		strcat(s_prg, "\\frac{");
		
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "}");

		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "{");
		code_to_Latex(prg[mep_index].addr2, s_prg, capacity);
			
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "}");

		break;
	case O_POWER:
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "{");
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		increase_string_capacity2(s_prg, capacity, 4);
		strcat(s_prg, "}^{");
		code_to_Latex(prg[mep_index].addr2, s_prg, capacity);
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "}");
		break;
	case O_SQRT:
		increase_string_capacity2(s_prg, capacity, 8);
		strcat(s_prg, "\\sqrt{");
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "}");
		break;
	case O_EXP:
		increase_string_capacity2(s_prg, capacity, 4);
		strcat(s_prg, "e^{");
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "}");
		break;
	case O_POW10:
		increase_string_capacity2(s_prg, capacity, 5);
		strcat(s_prg, "10^{");
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "}");
		break;
	case O_LN:
		increase_string_capacity2(s_prg, capacity, 7);
		strcat(s_prg, "\\ln {");
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "}");
		break;
	case O_LOG10:
		increase_string_capacity2(s_prg, capacity, 12);
		strcat(s_prg, "\\log_10 {");
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "}");
		break;
	case O_LOG2:
		increase_string_capacity2(s_prg, capacity, 10);
		strcat(s_prg, "\\log_2 {");
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "}");
		break;
	case O_FLOOR:
		increase_string_capacity2(s_prg, capacity, 9);
		strcat(s_prg, "\\floor(");
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, ")");
		break;
	case O_CEIL:
		increase_string_capacity2(s_prg, capacity, 8);
		strcat(s_prg, "\\ceil(");
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, ")");
		break;
	case O_ABS:
		increase_string_capacity2(s_prg, capacity, 7);
		strcat(s_prg, "\\abs{");
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "}");
		break;
	case O_INV:
		increase_string_capacity2(s_prg, capacity, 11);
		strcat(s_prg, "\\frac{1}{");

		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, ")");

		break;
	case O_NEG:
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "-");

		if (prg[prg[mep_index].addr1].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}

		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		if (prg[prg[mep_index].addr1].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}
		break;
	case O_X2:
		if (prg[prg[mep_index].addr1].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		if (prg[prg[mep_index].addr1].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "^2");

		break;
	case O_MIN:
		increase_string_capacity2(s_prg, capacity, 7);
		strcat(s_prg, "\\min{");

		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);

		increase_string_capacity2(s_prg, capacity, 3);
		strcat(s_prg, ", ");


		code_to_Latex(prg[mep_index].addr2, s_prg, capacity);

		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "}");

		break;
	case O_MAX:
		increase_string_capacity2(s_prg, capacity, 7);
		strcat(s_prg, "\\max{");

		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);

		increase_string_capacity2(s_prg, capacity, 3);
		strcat(s_prg, ", ");


		code_to_Latex(prg[mep_index].addr2, s_prg, capacity);

		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "}");
		break;
	case O_SIN:
		increase_string_capacity2(s_prg, capacity, 7);
		strcat(s_prg, "\\sin{");
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "}");
		break;
	case O_COS:
		increase_string_capacity2(s_prg, capacity, 7);
		strcat(s_prg, "\\cos{");
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "}");
		break;
	case O_TAN:
		increase_string_capacity2(s_prg, capacity, 7);
		strcat(s_prg, "\\tan{");
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "}");
		break;
	case O_ASIN:
		increase_string_capacity2(s_prg, capacity, 9);
		strcat(s_prg, "\\arcsin{");
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "}");
		break;
	case O_ACOS:
		increase_string_capacity2(s_prg, capacity, 9);
		strcat(s_prg, "\\arccos{");
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "}");
		break;
	case O_ATAN:
		increase_string_capacity2(s_prg, capacity, 9);
		strcat(s_prg, "arctan{");
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "}");
		break;
	case O_IFLZ:
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "(");

		if (prg[prg[mep_index].addr1].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		if (prg[prg[mep_index].addr1].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}

		increase_string_capacity2(s_prg, capacity, 4);
		strcat(s_prg, "<0?");

		if (prg[prg[mep_index].addr2].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}

		code_to_Latex(prg[mep_index].addr2, s_prg, capacity);

		if (prg[prg[mep_index].addr2].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, ":");

		if (prg[prg[mep_index].addr3].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}

		code_to_Latex(prg[mep_index].addr3, s_prg, capacity);
		if (prg[prg[mep_index].addr3].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, ")");

		break;
	case O_IFALBCD:
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "(");

		if (prg[prg[mep_index].addr1].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		if (prg[prg[mep_index].addr1].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "<");

		if (prg[prg[mep_index].addr2].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}
		code_to_Latex(prg[mep_index].addr2, s_prg, capacity);

		if (prg[prg[mep_index].addr2].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}

		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "?");

		if (prg[prg[mep_index].addr3].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}

		code_to_Latex(prg[mep_index].addr3, s_prg, capacity);

		if (prg[prg[mep_index].addr3].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, ":");

		if (prg[prg[mep_index].addr4].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}

		code_to_Latex(prg[mep_index].addr4, s_prg, capacity);
		if (prg[prg[mep_index].addr4].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, ")");

		break;
	case O_IF_A_OR_B_CD:
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "(");

		if (prg[prg[mep_index].addr1].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		if (prg[prg[mep_index].addr1].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}
		increase_string_capacity2(s_prg, capacity, 6);
		strcat(s_prg, "<0 ||");

		if (prg[prg[mep_index].addr2].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}
		code_to_Latex(prg[mep_index].addr2, s_prg, capacity);

		if (prg[prg[mep_index].addr2].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}

		increase_string_capacity2(s_prg, capacity, 4);
		strcat(s_prg, "<0?");

		if (prg[prg[mep_index].addr3].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}

		code_to_Latex(prg[mep_index].addr3, s_prg, capacity);

		if (prg[prg[mep_index].addr3].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, ":");

		if (prg[prg[mep_index].addr4].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}

		code_to_Latex(prg[mep_index].addr4, s_prg, capacity);
		if (prg[prg[mep_index].addr4].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, ")");

		break;
	case O_IF_A_XOR_B_CD:
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "(");
		if (prg[prg[mep_index].addr1].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		if (prg[prg[mep_index].addr1].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}
		increase_string_capacity2(s_prg, capacity, 6);
		strcat(s_prg, "<0 !=");

		if (prg[prg[mep_index].addr2].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}
		code_to_Latex(prg[mep_index].addr2, s_prg, capacity);

		if (prg[prg[mep_index].addr2].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}

		increase_string_capacity2(s_prg, capacity, 4);
		strcat(s_prg, "<0?");

		if (prg[prg[mep_index].addr3].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}

		code_to_Latex(prg[mep_index].addr3, s_prg, capacity);

		if (prg[prg[mep_index].addr3].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, ":");

		if (prg[prg[mep_index].addr4].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}

		code_to_Latex(prg[mep_index].addr4, s_prg, capacity);
		if (prg[prg[mep_index].addr4].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, ")");
		break;
	case O_FMOD:
			
		
		if (prg[prg[mep_index].addr1].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}
		code_to_Latex(prg[mep_index].addr1, s_prg, capacity);
		if (prg[prg[mep_index].addr1].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}
		increase_string_capacity2(s_prg, capacity, 2);
		strcat(s_prg, "%");
		if (prg[prg[mep_index].addr2].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, "(");
		}
		code_to_Latex(prg[mep_index].addr2, s_prg, capacity);
		if (prg[prg[mep_index].addr2].op < 0) { // it is an operator
			increase_string_capacity2(s_prg, capacity, 2);
			strcat(s_prg, ")");
		}

		break;

	case O_NUM_INPUTS:
		break;

	case O_INPUTS_AVERAGE:
		break;
	default:
		if (prg[mep_index].op >= 0) { // a variable
			if (prg[mep_index].op < (int)num_total_variables) {
				char tmp_s[100];
				if (problem_type == MEP_PROBLEM_TIME_SERIE &&
					num_program_outputs > 1)
					snprintf(tmp_s, 100, "x_{%u,%u}",
							 (unsigned int)prg[mep_index].op / num_program_outputs,
							 (unsigned int)prg[mep_index].op % num_program_outputs);
				else
					snprintf(tmp_s, 100, "x_{%u}", (unsigned int)prg[mep_index].op);
				size_t str_len = strlen(tmp_s);
				increase_string_capacity2(s_prg, capacity, str_len);
				strcat(s_prg, tmp_s);
			}
			else {
				char tmp_s[100];
				if (data_type == MEP_DATA_LONG_LONG)
					snprintf(tmp_s, 100, "%lld", long_constants[prg[mep_index].op - num_total_variables]);
				else
					snprintf(tmp_s, 100, "%lg", real_constants[prg[mep_index].op - num_total_variables]);

				size_t str_len = strlen(tmp_s);
				increase_string_capacity2(s_prg, capacity, str_len);
				strcat(s_prg, tmp_s);
			}
		}
	}
}
//---------------------------------------------------------------------------------
